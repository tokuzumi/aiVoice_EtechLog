name: CI/CD aiVoiceV3

on:
  push:
    branches: [ main ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout do c√≥digo
        uses: actions/checkout@v4

      - name: Login no GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GH_PAT }}

      - name: Build e Push - Backend (Orchestrator)
        run: |
          # Gera tag din√¢mica baseada no ID da inst√¢ncia para isolamento total
          export INSTANCE_TAG=$(echo "${{ vars.INSTANCE_ID }}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9_-]//g')
          docker build -t ghcr.io/${{ github.repository_owner }}/aivoice-backend:$INSTANCE_TAG ./server
          docker push ghcr.io/${{ github.repository_owner }}/aivoice-backend:$INSTANCE_TAG

      - name: Build e Push - Client (Website)
        run: |
          export INSTANCE_TAG=$(echo "${{ vars.INSTANCE_ID }}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9_-]//g')
          docker build \
            --build-arg VITE_AGENT_API_URL=https://${{ vars.DOMAIN_API }} \
            --build-arg VITE_DASHBOARD_API_URL=https://${{ vars.DOMAIN_DASH_API }} \
            --build-arg VITE_INSTANCE_ID=${{ vars.INSTANCE_ID }} \
            --build-arg VITE_INSTANCE_CLIENT_NAME="${{ vars.INSTANCE_CLIENT_NAME }}" \
            --build-arg VITE_CLIENT_TITLE="${{ vars.VITE_CLIENT_TITLE }}" \
            --build-arg VITE_CLIENT_DESCRIPTION="${{ vars.VITE_CLIENT_DESCRIPTION }}" \
            -t ghcr.io/${{ github.repository_owner }}/aivoice-client:$INSTANCE_TAG ./client
          docker push ghcr.io/${{ github.repository_owner }}/aivoice-client:$INSTANCE_TAG

      - name: Build e Push - Dashboard (Frontend)
        run: |
          export INSTANCE_TAG=$(echo "${{ vars.INSTANCE_ID }}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9_-]//g')
          docker build \
            --build-arg VITE_API_URL=https://${{ vars.DOMAIN_DASH_API }}/api \
            --build-arg VITE_INSTANCE_ID=${{ vars.INSTANCE_ID }} \
            --build-arg VITE_INSTANCE_CLIENT_NAME="${{ vars.INSTANCE_CLIENT_NAME }}" \
            -t ghcr.io/${{ github.repository_owner }}/aivoice-dashboard:$INSTANCE_TAG ./dashboard -f ./dashboard/Dockerfile.prod
          docker push ghcr.io/${{ github.repository_owner }}/aivoice-dashboard:$INSTANCE_TAG

      - name: Build e Push - DashServer (API)
        run: |
          export INSTANCE_TAG=$(echo "${{ vars.INSTANCE_ID }}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9_-]//g')
          docker build -t ghcr.io/${{ github.repository_owner }}/aivoice-dashboard-server:$INSTANCE_TAG ./dashboard-server
          docker push ghcr.io/${{ github.repository_owner }}/aivoice-dashboard-server:$INSTANCE_TAG

      - name: Deploy via SSH no Servidor
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_IP }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            set -e
            
            # Exporta e Sanitiza o nome do projeto (Docker exige apenas min√∫sculas e caracteres b√°sicos)
            export INSTANCE_ID_RAW="${{ vars.INSTANCE_ID }}"
            export INSTANCE_ID=$(echo "$INSTANCE_ID_RAW" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9_-]//g')
            
            export INSTANCE_CLIENT_NAME="${{ vars.INSTANCE_CLIENT_NAME }}"
            export DOMAIN_WEBSITE="${{ vars.DOMAIN_WEBSITE }}"
            export DOMAIN_API="${{ vars.DOMAIN_API }}"
            export DOMAIN_DASHBOARD="${{ vars.DOMAIN_DASHBOARD }}"
            export DOMAIN_DASH_API="${{ vars.DOMAIN_DASH_API }}"
            export GITHUB_REPOSITORY_OWNER="${{ github.repository_owner }}"

            # Secrets de Runtime (Injetadas pelo CI/CD para independ√™ncia do .env local)
            export DB_USER="${{ secrets.DB_USER }}"
            export DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
            export DB_NAME="${{ secrets.DB_NAME }}"
            export JWT_SECRET="${{ secrets.JWT_SECRET }}"
            export MEILI_MASTER_KEY="${{ secrets.MEILI_MASTER_KEY }}"
            
            # Define o nome do projeto para que redes/volumes sejam √∫nicos (Isolamento Real)
            export COMPOSE_PROJECT_NAME="aivoice_$INSTANCE_ID"
            
            mkdir -p /opt/$INSTANCE_ID_RAW
            cd /opt/$INSTANCE_ID_RAW

            # --- CORRE√á√ÉO CR√çTICA DE ROTEAMENTO (404) ---
            # For√ßa a cria√ß√£o de um .env din√¢mico para garantir que o docker-compose enxergue as vari√°veis
            # Isso sobrescreve qualquer .env antigo ou incompleto no servidor
            echo "Gerando .env din√¢mico para deploy..."
            cat <<EOF > .env
            INSTANCE_ID=$INSTANCE_ID
            INSTANCE_CLIENT_NAME=$INSTANCE_CLIENT_NAME
            COMPOSE_PROJECT_NAME=$COMPOSE_PROJECT_NAME
            
            # Dom√≠nios
            DOMAIN_WEBSITE=$DOMAIN_WEBSITE
            DOMAIN_API=$DOMAIN_API
            DOMAIN_DASHBOARD=$DOMAIN_DASHBOARD
            DOMAIN_DASH_API=$DOMAIN_DASH_API
            
            # Vari√°veis do GitHub
            GITHUB_REPOSITORY_OWNER=$GITHUB_REPOSITORY_OWNER
            
            # Vari√°veis Injetadas pelo Build (Vite) mas necess√°rias no Runtime se referenciadas
            VITE_CLIENT_TITLE="${{ vars.VITE_CLIENT_TITLE }}"
            VITE_CLIENT_DESCRIPTION="${{ vars.VITE_CLIENT_DESCRIPTION }}"
            VITE_INSTANCE_CLIENT_NAME="${{ vars.INSTANCE_CLIENT_NAME }}"
            
            # Secrets (DB/JWT/Meili)
            DB_USER=$DB_USER
            DB_PASSWORD=$DB_PASSWORD
            DB_NAME=$DB_NAME
            JWT_SECRET=$JWT_SECRET
            MEILI_MASTER_KEY=$MEILI_MASTER_KEY
            
            # Portas Din√¢micas (Se n√£o definidas, usa defaults do docker-compose)
            # (Adicione aqui se precisar controlar portas via GitHub Vars)
            EOF
            
            # Baixa arquivos atualizados diretamente do GitHub
            echo "üì• Atualizando arquivos de configura√ß√£o para $INSTANCE_ID..."
            
            mkdir -p database
            curl -f -H "Authorization: token ${{ secrets.GH_PAT }}" -H "Accept: application/vnd.github.v3.raw" -L -o docker-compose-PROD.yml https://api.github.com/repos/${{ github.repository }}/contents/docker-compose-PROD.yml
            curl -f -H "Authorization: token ${{ secrets.GH_PAT }}" -H "Accept: application/vnd.github.v3.raw" -L -o database/init.sql https://api.github.com/repos/${{ github.repository }}/contents/database/init.sql
            
            echo "${{ secrets.GH_PAT }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            docker compose -f docker-compose-PROD.yml pull
            
            echo "‚ö†Ô∏è REINICIANDO EM MODO COLD-START: ${{ vars.INSTANCE_ID }} ‚ö†Ô∏è"
            # Remove containers, redes e VOLUMES para for√ßar o init.sql e limpar caches
            docker compose -f docker-compose-PROD.yml down -v --remove-orphans
            
            docker compose -f docker-compose-PROD.yml up -d --remove-orphans
            
            docker image prune -f
            echo "‚úÖ Deploy finalizado para ${{ vars.INSTANCE_ID }}!"

            # Verifica√ß√£o extra de conectividade interna
            if ! docker compose -f docker-compose-PROD.yml exec -T orchestrator wget --spider -q http://localhost:8080/health; then
               echo "‚ö†Ô∏è AVISO: Backend (orchestrator) parece n√£o estar respondendo na porta 8080 internamente."
            fi
